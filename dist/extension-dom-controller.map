{"version":3,"file":"extension-dom-controller.js","mappings":";;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACvJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACpGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACvKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC1GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACtXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACzFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACtDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACxPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC3KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACtDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC/EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACvPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC/FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AClIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AChCA;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACjFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://reddit-ss-generator/./node_modules/base64-js/index.js","webpack://reddit-ss-generator/./node_modules/canvas/browser.js","webpack://reddit-ss-generator/./node_modules/canvas/lib/parse-font.js","webpack://reddit-ss-generator/./node_modules/linebreak-next/src/classes.js","webpack://reddit-ss-generator/./node_modules/linebreak-next/src/linebreaker-browser.js","webpack://reddit-ss-generator/./node_modules/linebreak-next/src/pairs.js","webpack://reddit-ss-generator/./node_modules/once/once.js","webpack://reddit-ss-generator/./node_modules/simple-concat/index.js","webpack://reddit-ss-generator/./node_modules/simple-get/index.js","webpack://reddit-ss-generator/./node_modules/tiny-inflate/index.js","webpack://reddit-ss-generator/./node_modules/ultimate-text-to-image/build/BaseClass.js","webpack://reddit-ss-generator/./node_modules/ultimate-text-to-image/build/HorizontalImage.js","webpack://reddit-ss-generator/./node_modules/ultimate-text-to-image/build/Measurable.js","webpack://reddit-ss-generator/./node_modules/ultimate-text-to-image/build/UltimateTextToImage.js","webpack://reddit-ss-generator/./node_modules/ultimate-text-to-image/build/UnicodeLineBreak.js","webpack://reddit-ss-generator/./node_modules/ultimate-text-to-image/build/VerticalImage.js","webpack://reddit-ss-generator/./node_modules/ultimate-text-to-image/build/getCanvasImage.js","webpack://reddit-ss-generator/./node_modules/ultimate-text-to-image/build/index.js","webpack://reddit-ss-generator/./node_modules/ultimate-text-to-image/build/registerFont.js","webpack://reddit-ss-generator/./node_modules/ultimate-text-to-image/build/utils/canvas.js","webpack://reddit-ss-generator/./node_modules/ultimate-text-to-image/build/utils/index.js","webpack://reddit-ss-generator/./node_modules/unicode-trie/index.js","webpack://reddit-ss-generator/./node_modules/wrappy/wrappy.js","webpack://reddit-ss-generator/ignored|C:\\Users\\mohit\\Documents\\gitHub\\extensions\\reddit-screenshot-generator\\node_modules\\simple-get|decompress-response","webpack://reddit-ss-generator/webpack/bootstrap","webpack://reddit-ss-generator/./src/extension-dom-controller.js","webpack://reddit-ss-generator/./src/tab-dom-controller.js"],"sourcesContent":["'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(\n      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)\n    ))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n","/* globals document, ImageData */\n\nconst parseFont = require('./lib/parse-font')\n\nexports.parseFont = parseFont\n\nexports.createCanvas = function (width, height) {\n  return Object.assign(document.createElement('canvas'), { width: width, height: height })\n}\n\nexports.createImageData = function (array, width, height) {\n  // Browser implementation of ImageData looks at the number of arguments passed\n  switch (arguments.length) {\n    case 0: return new ImageData()\n    case 1: return new ImageData(array)\n    case 2: return new ImageData(array, width)\n    default: return new ImageData(array, width, height)\n  }\n}\n\nexports.loadImage = function (src, options) {\n  return new Promise(function (resolve, reject) {\n    const image = Object.assign(document.createElement('img'), options)\n\n    function cleanup () {\n      image.onload = null\n      image.onerror = null\n    }\n\n    image.onload = function () { cleanup(); resolve(image) }\n    image.onerror = function () { cleanup(); reject(new Error('Failed to load the image \"' + src + '\"')) }\n\n    image.src = src\n  })\n}\n","'use strict'\n\n/**\n * Font RegExp helpers.\n */\n\nconst weights = 'bold|bolder|lighter|[1-9]00'\nconst styles = 'italic|oblique'\nconst variants = 'small-caps'\nconst stretches = 'ultra-condensed|extra-condensed|condensed|semi-condensed|semi-expanded|expanded|extra-expanded|ultra-expanded'\nconst units = 'px|pt|pc|in|cm|mm|%|em|ex|ch|rem|q'\nconst string = '\\'([^\\']+)\\'|\"([^\"]+)\"|[\\\\w\\\\s-]+'\n\n// [ [ <‘font-style’> || <font-variant-css21> || <‘font-weight’> || <‘font-stretch’> ]?\n//    <‘font-size’> [ / <‘line-height’> ]? <‘font-family’> ]\n// https://drafts.csswg.org/css-fonts-3/#font-prop\nconst weightRe = new RegExp(`(${weights}) +`, 'i')\nconst styleRe = new RegExp(`(${styles}) +`, 'i')\nconst variantRe = new RegExp(`(${variants}) +`, 'i')\nconst stretchRe = new RegExp(`(${stretches}) +`, 'i')\nconst sizeFamilyRe = new RegExp(\n  `([\\\\d\\\\.]+)(${units}) *((?:${string})( *, *(?:${string}))*)`)\n\n/**\n * Cache font parsing.\n */\n\nconst cache = {}\n\nconst defaultHeight = 16 // pt, common browser default\n\n/**\n * Parse font `str`.\n *\n * @param {String} str\n * @return {Object} Parsed font. `size` is in device units. `unit` is the unit\n *   appearing in the input string.\n * @api private\n */\n\nmodule.exports = str => {\n  // Cached\n  if (cache[str]) return cache[str]\n\n  // Try for required properties first.\n  const sizeFamily = sizeFamilyRe.exec(str)\n  if (!sizeFamily) return // invalid\n\n  // Default values and required properties\n  const font = {\n    weight: 'normal',\n    style: 'normal',\n    stretch: 'normal',\n    variant: 'normal',\n    size: parseFloat(sizeFamily[1]),\n    unit: sizeFamily[2],\n    family: sizeFamily[3].replace(/[\"']/g, '').replace(/ *, */g, ',')\n  }\n\n  // Optional, unordered properties.\n  let weight, style, variant, stretch\n  // Stop search at `sizeFamily.index`\n  const substr = str.substring(0, sizeFamily.index)\n  if ((weight = weightRe.exec(substr))) font.weight = weight[1]\n  if ((style = styleRe.exec(substr))) font.style = style[1]\n  if ((variant = variantRe.exec(substr))) font.variant = variant[1]\n  if ((stretch = stretchRe.exec(substr))) font.stretch = stretch[1]\n\n  // Convert to device units. (`font.unit` is the original unit)\n  // TODO: ch, ex\n  switch (font.unit) {\n    case 'pt':\n      font.size /= 0.75\n      break\n    case 'pc':\n      font.size *= 16\n      break\n    case 'in':\n      font.size *= 96\n      break\n    case 'cm':\n      font.size *= 96.0 / 2.54\n      break\n    case 'mm':\n      font.size *= 96.0 / 25.4\n      break\n    case '%':\n      // TODO disabled because existing unit tests assume 100\n      // font.size *= defaultHeight / 100 / 0.75\n      break\n    case 'em':\n    case 'rem':\n      font.size *= defaultHeight / 0.75\n      break\n    case 'q':\n      font.size *= 96 / 25.4 / 4\n      break\n  }\n\n  return (cache[str] = font)\n}\n","// The following break classes are handled by the pair table\r\n\r\nexports.OP = 0;   // Opening punctuation\r\nexports.CL = 1;   // Closing punctuation\r\nexports.CP = 2;   // Closing parenthesis\r\nexports.QU = 3;   // Ambiguous quotation\r\nexports.GL = 4;   // Glue\r\nexports.NS = 5;   // Non-starters\r\nexports.EX = 6;   // Exclamation/Interrogation\r\nexports.SY = 7;   // Symbols allowing break after\r\nexports.IS = 8;   // Infix separator\r\nexports.PR = 9;   // Prefix\r\nexports.PO = 10;  // Postfix\r\nexports.NU = 11;  // Numeric\r\nexports.AL = 12;  // Alphabetic\r\nexports.HL = 13;  // Hebrew Letter\r\nexports.ID = 14;  // Ideographic\r\nexports.IN = 15;  // Inseparable characters\r\nexports.HY = 16;  // Hyphen\r\nexports.BA = 17;  // Break after\r\nexports.BB = 18;  // Break before\r\nexports.B2 = 19;  // Break on either side (but not pair)\r\nexports.ZW = 20;  // Zero-width space\r\nexports.CM = 21;  // Combining marks\r\nexports.WJ = 22;  // Word joiner\r\nexports.H2 = 23;  // Hangul LV\r\nexports.H3 = 24;  // Hangul LVT\r\nexports.JL = 25;  // Hangul L Jamo\r\nexports.JV = 26;  // Hangul V Jamo\r\nexports.JT = 27;  // Hangul T Jamo\r\nexports.RI = 28;  // Regional Indicator\r\n\r\n// The following break classes are not handled by the pair table\r\nexports.AI = 29;  // Ambiguous (Alphabetic or Ideograph)\r\nexports.BK = 30;  // Break (mandatory)\r\nexports.CB = 31;  // Contingent break\r\nexports.CJ = 32;  // Conditional Japanese Starter\r\nexports.CR = 33;  // Carriage return\r\nexports.LF = 34;  // Line feed\r\nexports.NL = 35;  // Next line\r\nexports.SA = 36;  // South-East Asian\r\nexports.SG = 37;  // Surrogates\r\nexports.SP = 38;  // Space\r\nexports.XX = 39;  // Unknown\r\n","const base64 = require('base64-js');\nconst UnicodeTrie = require('unicode-trie');\r\n\r\nconst { BK, CR, LF, NL, SG, WJ, CB, SP, BA, NS, AI, AL, CJ, ID, SA, XX } = require('./classes');\r\nconst { DI_BRK, IN_BRK, CI_BRK, CP_BRK, PR_BRK, pairTable } = require('./pairs');\r\n\r\nconst data = base64.toByteArray(\"AA4IAAAAAAAAAhqg5VV7NJtZvz7fTC8zU5deplUlMrQoWqmqahD5So0aipYWrUhVFSVBQ10iSTtUtW6nKDVF6k7d75eQfEUbFcQ9KiFS90tQEolcP23nrLPmO+esr/+f39rr/a293t/e7/P8nmfvlz0O6RvrBJADtbBNaD88IOKTOmOrCqhu9zE770vc1pBV/xL5dxj2V7Zj4FGSomFKStCWNlV7hG1VabZfZ1LaHbFrRwzzLjzPoi1UHDnlV/lWbhgIIJvLBp/pu7AHEdRnIY+ROdXxg4fNpMdTxVnnm08OjozejAVsBqwqz8kddGRlRxsd8c55dNZoPuex6a7Dt6L0NNb03sqgTlR2/OT7eTt0Y0WnpUXxLsp5SMANc4DsmX4zJUBQvznwexm9tsMH+C9uRYMPOd96ZHB29NZjCIM2nfO7tsmQveX3l2r7ft0N4/SRJ7kO6Y8ZCaeuUQ4gMTZ67cp7TgxvlNDsPgOBdZi2YTam5Q7m3+00l+XG7PrDe6YoPmHgK+yLih7fAR16ZFCeD9WvOVt+gfNW/KT5/M6rb/9KERt+N1lad5RneVjzxXHsLofuU+TvrEsr3+26sVz5WJh6L/svoPK3qepFH9bysDljWtD1F7KrxzW1i9r+e/NLxV/acts7zuo304J9+t3Pd6Y6u8f3EAqxNRgv5DZjaI3unyvkvHPya/v3mWVYOC38qBq11+yHZ2bAyP1HbkV92vdno7r2lxz9UwCdCJVfd14NLcpO2CadHS/XPJ9doXgz5vLv/1OBVS3gX0D9n6LiNIDfpilO9RsLgZ2W/wIy8W/Rh93jfoz4qmRV2xElv6p2lRXQdO6/Cv8f5nGn3u0wLXjhnvClabL1o+7yvIpvLfT/xsKG30y/sTvq30ia9Czxp9dr9v/e7Yn/O0QJXxxBOJmceP/DBFa1q1v6oudn/e6qc/37dUoNvnYL4plQ9OoneYOh/r8fOFm7yl7FETHY9dXd5K2n/qEc53dOEe1TTJcvCfp1dpTC334l0vyaFL6mttNEbFjzO+ZV2mLk0qc3BrxJ4d9gweMmjRorxb7vic0rSq6D4wzAyFWas1TqPE0sLI8XLAryC8tPChaN3ALEZSWmtB34SyZcxXYn/E4Tg0LeMIPhgPKD9zyHGMxxhxnDDih7eI86xECTM8zodUCdgffUmRh4rQ8zyA6ow/Aei+01a8OMfziQQ+GAEkhwN/cqUFYAVzA9ex4n6jgtsiMvXf5BtXxEU4hSphvx3v8+9au8eEekEEpkrkne/zB1M+HAPuXIz3paxKlfe8aDMfGWAX6Md6PuuAdKHFVH++Ed5LEji94Z5zeiJIxbmWeN7rr1/ZcaBl5/nimdHsHgIH/ssyLUXZ4fDQ46HnBb+hQqG8yNiKRrXL/b1IPYDUsu3dFKtRMcjqlRvONd4xBvOufx2cUHuk8pmG1D7PyOQmUmluisVFS9OWS8fPIe8LiCtjwJKnEC9hrS9uKmISI3Wa5+vdXUG9dtyfr7g/oJv2wbzeZU838G6mEvntUb3SVV/fBZ6H/sL+lElzeRrHy2Xbe7UWX1q5sgOQ81rv+2baej4fP4m5Mf/GkoxfDtT3++KP7do9Jn26aa6xAhCf5L9RZVfkWKCcjI1eYbm2plvTEqkDxKC402bGzXCYaGnuALHabBT1dFLuOSB7RorOPEhZah1NjZIgR/UFGfK3p1ElYnevOMBDLURdpIjrI+qZk4sffGbRFiXuEmdFjiAODlQCJvIaB1rW61Ljg3y4eS4LAcSgDxxZQs0DYa15wA032Z+lGUfpoyOrFo3mg1sRQtN/fHHCx3TrM8eTrldMbYisDLXbUDoXMLejSq0fUNuO1muX0gEa8vgyegkqiqqbC3W0S4cC9Kmt8MuS/hFO7Xei3f8rSvIjeveMM7kxjUixOrl6gJshe4JU7PhOHpfrRYvu7yoAZKa3Buyk2J+K5W+nNTz1nhJDhRUfDJLiUXxjxXCJeeaOe/r7HlBP/uURc/5efaZEPxr55Qj39rfTLkugUGyMrwo7HAglfEjDriehF1jXtwJkPoiYkYQ5aoXSA7qbCBGKq5hwtu2VkpI9xVDop/1xrC52eiIvCoPWx4lLl40jm9upvycVPfpaH9/o2D4xKXpeNjE2HPQRS+3RFaYTc4Txw7Dvq5X6JBRwzs9mvoB49BK6b+XgsZVJYiInTlSXZ+62FT18mkFVcPKCJsoF5ahb19WheZLUYsSwdrrVM3aQ2XE6SzU2xHDS6iWkodk5AF6F8WUNmmushi8aVpMPwiIfEiQWo3CApONDRjrhDiVnkaFsaP5rjIJkmsN6V26li5LNM3JxGSyKgomknTyyrhcnwv9Qcqaq5utAh44W30SWo8Q0XHKR0glPF4fWst1FUCnk2woFq3iy9fAbzcjJ8fvSjgKVOfn14RDqyQuIgaGJZuswTywdCFSa89SakMf6fe+9KaQMYQlKxiJBczuPSho4wmBjdA+ag6QUOr2GdpcbSl51Ay6khhBt5UXdrnxc7ZGMxCvz96A4oLocxh2+px+1zkyLacCGrxnPzTRSgrLKpStFpH5ppKWm7PgMKZtwgytKLOjbGCOQLTm+KOowqa1sdut9raj1CZFkZD0jbaKNLpJUarSH5Qknx1YiOxdA5L6d5sfI/unmkSF65Ic/AvtXt98Pnrdwl5vgppQ3dYzWFwknZsy6xh2llmLxpegF8ayLwniknlXRHiF4hzzrgB8jQ4wdIqcaHCEAxyJwCeGkXPBZYSrrGa4vMwZvNN9aK0F4JBOK9mQ8g8EjEbIQVwvfS2D8GuCYsdqwqSWbQrfWdTRUJMqmpnWPax4Z7E137I6brHbvjpPlfNZpF1d7PP7HB/MPHcHVKTMhLO4f3CZcaccZEOiS2DpKiQB5KXDJ+Ospcz4qTRCRxgrKEQIgUkKLTKKwskdx2DWo3bg3PEoB5h2nA24olwfKSR+QR6TAvEDi/0czhUT59RZmO1MGeKGeEfuOSPWfL+XKmhqpZmOVR9mJVNDPKOS49Lq+Um10YsBybzDMtemlPCOJEtE8zaXhsaqEs9bngSJGhlOTTMlCXly9Qv5cRN3PVLK7zoMptutf7ihutrQ/Xj7VqeCdUwleTTKklOI8Wep9h7fCY0kVtDtIWKnubWAvbNZtsRRqOYl802vebPEkZRSZc6wXOfPtpPtN5HI63EUFfsy7U/TLr8NkIzaY3vx4A28x765XZMzRZTpMk81YIMuwJ5+/zoCuZj1wGnaHObxa5rpKZj4WhT670maRw04w0e3cZW74Z0aZe2n05hjZaxm6urenz8Ef5O6Yu1J2aqYAlqsCXs5ZB5o1JJ5l3xkTVr8rJQ09NLsBqRRDT2IIjOPmcJa6xQ1R5yGP9jAsj23xYDTezdyqG8YWZ7vJBIWK56K+iDgcHimiQOTIasNSua1fOBxsKMMEKd15jxTl+3CyvGCR+UyRwuSI2XuwRIPoNNclPihfJhaq2mKkNijwYLY6feqohktukmI3KDvOpN7ItCqHHhNuKlxMfBAEO5LjW2RKh6lE5Hd1dtAOopac/Z4FdsNsjMhXz/ug8JGmbVJTA+VOBJXdrYyJcIn5+OEeoK8kWEWF+wdG8ZtZHKSquWDtDVyhFPkRVqguKFkLkKCz46hcU1SUY9oJ2Sk+dmq0kglqk4kqKT1CV9JDELPjK1WsWGkEXF87g9P98e5ff0mIupm/w6vc3kCeq04X5bgJQlcMFRjlFWmSk+kssXCAVikfeAlMuzpUvCSdXiG+dc6KrIiLxxhbEVuKf7vW7KmDQI95bZe3H9mN3/77F6fZ2Yx/F9yClllj8gXpLWLpd5+v90iOaFa9sd7Pvx0lNa1o1+bkiZ69wCiC2x9UIb6/boBCuNMB/HYR0RC6+FD9Oe5qrgQl6JbXtkaYn0wkdNhROLqyhv6cKvyMj1Fvs2o3OOKoMYTubGENLfY5F6H9d8wX1cnINsvz+wZFQu3zhWVlwJvwBEp69Dqu/ZnkBf3nIfbx4TK7zOVJH5sGJX+IMwkn1vVBn38GbpTg9bJnMcTOb5F6Ci5gOn9Fcy6Qzcu+FL6mYJJ+f2ZZJGda1VqruZ0JRXItp8X0aTjIcJgzdaXlha7q7kV4ebrMsunfsRyRa9qYuryBHA0hc1KVsKdE+oI0ljLmSAyMze8lWmc5/lQ18slyTVC/vADTc+SNM5++gztTBLz4m0aVUKcfgOEExuKVomJ7XQDZuziMDjG6JP9tgR7JXZTeo9RGetW/Xm9/TgPJpTgHACPOGvmy2mDm9fl09WeMm9sQUAXP3Su2uApeCwJVT5iWCXDgmcuTsFgU9Nm6/PusJzSbDQIMfl6INY/OAEvZRN54BSSXUClM51im6Wn9VhVamKJmzOaFJErgJcs0etFZ40LIF3EPkjFTjGmAhsd174NnOwJW8TdJ1Dja+E6Wa6FVS22Haj1DDA474EesoMP5nbspAPJLWJ8rYcP1DwCslhnn+gTFm+sS9wY+U6SogAa9tiwpoxuaFeqm2OK+uozR6SfiLCOPz36LiDlzXr6UWd7BpY6mlrNANkTOeme5EgnnAkQRTGo9T6iYxbUKfGJcI9B+ub2PcyUOgpwXbOf3bHFWtygD7FYbRhb+vkzi87dB0JeXl/vBpBUz93VtqZi7AL7C1VowTF+tGmyurw7DBcktc+UMY0E10Jw4URojf8NdaNpN6E1q4+Oz+4YePtMLy8FPRP\");\r\n\r\nconst classTrie = new UnicodeTrie(data);\r\n\r\nconst mapClass = function (c) {\r\n  switch (c) {\r\n    case AI:\r\n      return AL;\r\n\r\n    case SA:\r\n    case SG:\r\n    case XX:\r\n      return AL;\r\n\r\n    case CJ:\r\n      return NS;\r\n\r\n    default:\r\n      return c;\r\n  }\r\n};\r\n\r\nconst mapFirst = function (c) {\r\n  switch (c) {\r\n    case LF:\r\n    case NL:\r\n      return BK;\r\n\r\n    case CB:\r\n      return BA;\r\n\r\n    case SP:\r\n      return WJ;\r\n\r\n    default:\r\n      return c;\r\n  }\r\n};\r\n\r\nclass Break {\r\n  constructor(position, required = false) {\r\n    this.position = position;\r\n    this.required = required;\r\n  }\r\n}\r\n\r\nclass LineBreaker {\r\n  constructor(string) {\r\n    this.string = string;\r\n    this.pos = 0;\r\n    this.lastPos = 0;\r\n    this.curClass = null;\r\n    this.nextClass = null;\r\n  }\r\n\r\n  nextCodePoint() {\r\n    const code = this.string.charCodeAt(this.pos++);\r\n    const next = this.string.charCodeAt(this.pos);\r\n\r\n    // If a surrogate pair\r\n    if ((0xd800 <= code && code <= 0xdbff) && (0xdc00 <= next && next <= 0xdfff)) {\r\n      this.pos++;\r\n      return ((code - 0xd800) * 0x400) + (next - 0xdc00) + 0x10000;\r\n    }\r\n\r\n    return code;\r\n  }\r\n\r\n  nextCharClass() {\r\n    return mapClass(classTrie.get(this.nextCodePoint()));\r\n  }\r\n\r\n  nextBreak() {\r\n    // get the first char if we're at the beginning of the string\r\n    if (this.curClass == null) {\r\n      this.curClass = mapFirst(this.nextCharClass());\r\n    }\r\n\r\n    while (this.pos < this.string.length) {\r\n      this.lastPos = this.pos;\r\n      const lastClass = this.nextClass;\r\n      this.nextClass = this.nextCharClass();\r\n\r\n      // explicit newline\r\n      if ((this.curClass === BK) || ((this.curClass === CR) && (this.nextClass !== LF))) {\r\n        this.curClass = mapFirst(mapClass(this.nextClass));\r\n        return new Break(this.lastPos, true);\r\n      }\r\n\r\n      // handle classes not handled by the pair table\r\n      let cur;\r\n      switch (this.nextClass) {\r\n        case SP:\r\n          cur = this.curClass;\r\n          break;\r\n\r\n        case BK:\r\n        case LF:\r\n        case NL:\r\n          cur = BK;\r\n          break;\r\n\r\n        case CR:\r\n          cur = CR;\r\n          break;\r\n\r\n        case CB:\r\n          cur = BA;\r\n          break;\r\n      }\r\n\r\n      if (cur != null) {\r\n        this.curClass = cur;\r\n        if (this.nextClass === CB) {\r\n          return new Break(this.lastPos);\r\n        }\r\n        continue;\r\n      }\r\n\r\n      // if not handled already, use the pair table\r\n      let shouldBreak = false;\r\n      switch (pairTable[this.curClass][this.nextClass]) {\r\n        case DI_BRK: // Direct break\r\n          shouldBreak = true;\r\n          break;\r\n\r\n        case IN_BRK: // possible indirect break\r\n          shouldBreak = lastClass === SP;\r\n          break;\r\n\r\n        case CI_BRK:\r\n          shouldBreak = lastClass === SP;\r\n          if (!shouldBreak) {\r\n            continue;\r\n          }\r\n          break;\r\n\r\n        case CP_BRK: // prohibited for combining marks\r\n          if (lastClass !== SP) {\r\n            continue;\r\n          }\r\n          break;\r\n      }\r\n\r\n      this.curClass = this.nextClass;\r\n      if (shouldBreak) {\r\n        return new Break(this.lastPos);\r\n      }\r\n    }\r\n\r\n    if (this.pos >= this.string.length) {\r\n      if (this.lastPos < this.string.length) {\r\n        this.lastPos = this.string.length;\r\n        return new Break(this.string.length);\r\n      } else {\r\n        return null;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = LineBreaker;\r\n","let CI_BRK, CP_BRK, DI_BRK, IN_BRK, PR_BRK;\r\nexports.DI_BRK = (DI_BRK = 0); // Direct break opportunity\r\nexports.IN_BRK = (IN_BRK = 1); // Indirect break opportunity\r\nexports.CI_BRK = (CI_BRK = 2); // Indirect break opportunity for combining marks\r\nexports.CP_BRK = (CP_BRK = 3); // Prohibited break for combining marks\r\nexports.PR_BRK = (PR_BRK = 4); // Prohibited break\r\n\r\n// table generated from http://www.unicode.org/reports/tr14/#Table2\r\nexports.pairTable = [\r\n  [PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, CP_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK],\r\n  [DI_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK],\r\n  [DI_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK],\r\n  [PR_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, CI_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK],\r\n  [IN_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, CI_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK],\r\n  [DI_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK],\r\n  [DI_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK],\r\n  [DI_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, DI_BRK, IN_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK],\r\n  [DI_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK],\r\n  [IN_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK],\r\n  [IN_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK],\r\n  [IN_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK],\r\n  [IN_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK],\r\n  [IN_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK],\r\n  [DI_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, IN_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK],\r\n  [DI_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK],\r\n  [DI_BRK, PR_BRK, PR_BRK, IN_BRK, DI_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, DI_BRK, IN_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK],\r\n  [DI_BRK, PR_BRK, PR_BRK, IN_BRK, DI_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK],\r\n  [IN_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, CI_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK],\r\n  [DI_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, DI_BRK, PR_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK],\r\n  [DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK],\r\n  [IN_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK],\r\n  [IN_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, CI_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK],\r\n  [DI_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, IN_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, DI_BRK],\r\n  [DI_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, IN_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, DI_BRK],\r\n  [DI_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, IN_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK],\r\n  [DI_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, IN_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, DI_BRK],\r\n  [DI_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, IN_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, DI_BRK],\r\n  [DI_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK]\r\n];","var wrappy = require('wrappy')\nmodule.exports = wrappy(once)\nmodule.exports.strict = wrappy(onceStrict)\n\nonce.proto = once(function () {\n  Object.defineProperty(Function.prototype, 'once', {\n    value: function () {\n      return once(this)\n    },\n    configurable: true\n  })\n\n  Object.defineProperty(Function.prototype, 'onceStrict', {\n    value: function () {\n      return onceStrict(this)\n    },\n    configurable: true\n  })\n})\n\nfunction once (fn) {\n  var f = function () {\n    if (f.called) return f.value\n    f.called = true\n    return f.value = fn.apply(this, arguments)\n  }\n  f.called = false\n  return f\n}\n\nfunction onceStrict (fn) {\n  var f = function () {\n    if (f.called)\n      throw new Error(f.onceError)\n    f.called = true\n    return f.value = fn.apply(this, arguments)\n  }\n  var name = fn.name || 'Function wrapped with `once`'\n  f.onceError = name + \" shouldn't be called more than once\"\n  f.called = false\n  return f\n}\n","/*! simple-concat. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\nmodule.exports = function (stream, cb) {\n  var chunks = []\n  stream.on('data', function (chunk) {\n    chunks.push(chunk)\n  })\n  stream.once('end', function () {\n    if (cb) cb(null, Buffer.concat(chunks))\n    cb = null\n  })\n  stream.once('error', function (err) {\n    if (cb) cb(err)\n    cb = null\n  })\n}\n","module.exports = simpleGet\n\nconst concat = require('simple-concat')\nconst decompressResponse = require('decompress-response') // excluded from browser build\nconst http = require('http')\nconst https = require('https')\nconst once = require('once')\nconst querystring = require('querystring')\nconst url = require('url')\n\nconst isStream = o => o !== null && typeof o === 'object' && typeof o.pipe === 'function'\n\nfunction simpleGet (opts, cb) {\n  opts = Object.assign({ maxRedirects: 10 }, typeof opts === 'string' ? { url: opts } : opts)\n  cb = once(cb)\n\n  if (opts.url) {\n    const { hostname, port, protocol, auth, path } = url.parse(opts.url) // eslint-disable-line node/no-deprecated-api\n    delete opts.url\n    if (!hostname && !port && !protocol && !auth) opts.path = path // Relative redirect\n    else Object.assign(opts, { hostname, port, protocol, auth, path }) // Absolute redirect\n  }\n\n  const headers = { 'accept-encoding': 'gzip, deflate' }\n  if (opts.headers) Object.keys(opts.headers).forEach(k => (headers[k.toLowerCase()] = opts.headers[k]))\n  opts.headers = headers\n\n  let body\n  if (opts.body) {\n    body = opts.json && !isStream(opts.body) ? JSON.stringify(opts.body) : opts.body\n  } else if (opts.form) {\n    body = typeof opts.form === 'string' ? opts.form : querystring.stringify(opts.form)\n    opts.headers['content-type'] = 'application/x-www-form-urlencoded'\n  }\n\n  if (body) {\n    if (!opts.method) opts.method = 'POST'\n    if (!isStream(body)) opts.headers['content-length'] = Buffer.byteLength(body)\n    if (opts.json && !opts.form) opts.headers['content-type'] = 'application/json'\n  }\n  delete opts.body; delete opts.form\n\n  if (opts.json) opts.headers.accept = 'application/json'\n  if (opts.method) opts.method = opts.method.toUpperCase()\n\n  const originalHost = opts.hostname // hostname before potential redirect\n  const protocol = opts.protocol === 'https:' ? https : http // Support http/https urls\n  const req = protocol.request(opts, res => {\n    if (opts.followRedirects !== false && res.statusCode >= 300 && res.statusCode < 400 && res.headers.location) {\n      opts.url = res.headers.location // Follow 3xx redirects\n      delete opts.headers.host // Discard `host` header on redirect (see #32)\n      res.resume() // Discard response\n\n      const redirectHost = url.parse(opts.url).hostname // eslint-disable-line node/no-deprecated-api\n      // If redirected host is different than original host, drop headers to prevent cookie leak (#73)\n      if (redirectHost !== null && redirectHost !== originalHost) {\n        delete opts.headers.cookie\n        delete opts.headers.authorization\n      }\n\n      if (opts.method === 'POST' && [301, 302].includes(res.statusCode)) {\n        opts.method = 'GET' // On 301/302 redirect, change POST to GET (see #35)\n        delete opts.headers['content-length']; delete opts.headers['content-type']\n      }\n\n      if (opts.maxRedirects-- === 0) return cb(new Error('too many redirects'))\n      else return simpleGet(opts, cb)\n    }\n\n    const tryUnzip = typeof decompressResponse === 'function' && opts.method !== 'HEAD'\n    cb(null, tryUnzip ? decompressResponse(res) : res)\n  })\n  req.on('timeout', () => {\n    req.abort()\n    cb(new Error('Request timed out'))\n  })\n  req.on('error', cb)\n\n  if (isStream(body)) body.on('error', cb).pipe(req)\n  else req.end(body)\n\n  return req\n}\n\nsimpleGet.concat = (opts, cb) => {\n  return simpleGet(opts, (err, res) => {\n    if (err) return cb(err)\n    concat(res, (err, data) => {\n      if (err) return cb(err)\n      if (opts.json) {\n        try {\n          data = JSON.parse(data.toString())\n        } catch (err) {\n          return cb(err, res, data)\n        }\n      }\n      cb(null, res, data)\n    })\n  })\n}\n\n;['get', 'post', 'put', 'patch', 'head', 'delete'].forEach(method => {\n  simpleGet[method] = (opts, cb) => {\n    if (typeof opts === 'string') opts = { url: opts }\n    return simpleGet(Object.assign({ method: method.toUpperCase() }, opts), cb)\n  }\n})\n","var TINF_OK = 0;\nvar TINF_DATA_ERROR = -3;\n\nfunction Tree() {\n  this.table = new Uint16Array(16);   /* table of code length counts */\n  this.trans = new Uint16Array(288);  /* code -> symbol translation table */\n}\n\nfunction Data(source, dest) {\n  this.source = source;\n  this.sourceIndex = 0;\n  this.tag = 0;\n  this.bitcount = 0;\n  \n  this.dest = dest;\n  this.destLen = 0;\n  \n  this.ltree = new Tree();  /* dynamic length/symbol tree */\n  this.dtree = new Tree();  /* dynamic distance tree */\n}\n\n/* --------------------------------------------------- *\n * -- uninitialized global data (static structures) -- *\n * --------------------------------------------------- */\n\nvar sltree = new Tree();\nvar sdtree = new Tree();\n\n/* extra bits and base tables for length codes */\nvar length_bits = new Uint8Array(30);\nvar length_base = new Uint16Array(30);\n\n/* extra bits and base tables for distance codes */\nvar dist_bits = new Uint8Array(30);\nvar dist_base = new Uint16Array(30);\n\n/* special ordering of code length codes */\nvar clcidx = new Uint8Array([\n  16, 17, 18, 0, 8, 7, 9, 6,\n  10, 5, 11, 4, 12, 3, 13, 2,\n  14, 1, 15\n]);\n\n/* used by tinf_decode_trees, avoids allocations every call */\nvar code_tree = new Tree();\nvar lengths = new Uint8Array(288 + 32);\n\n/* ----------------------- *\n * -- utility functions -- *\n * ----------------------- */\n\n/* build extra bits and base tables */\nfunction tinf_build_bits_base(bits, base, delta, first) {\n  var i, sum;\n\n  /* build bits table */\n  for (i = 0; i < delta; ++i) bits[i] = 0;\n  for (i = 0; i < 30 - delta; ++i) bits[i + delta] = i / delta | 0;\n\n  /* build base table */\n  for (sum = first, i = 0; i < 30; ++i) {\n    base[i] = sum;\n    sum += 1 << bits[i];\n  }\n}\n\n/* build the fixed huffman trees */\nfunction tinf_build_fixed_trees(lt, dt) {\n  var i;\n\n  /* build fixed length tree */\n  for (i = 0; i < 7; ++i) lt.table[i] = 0;\n\n  lt.table[7] = 24;\n  lt.table[8] = 152;\n  lt.table[9] = 112;\n\n  for (i = 0; i < 24; ++i) lt.trans[i] = 256 + i;\n  for (i = 0; i < 144; ++i) lt.trans[24 + i] = i;\n  for (i = 0; i < 8; ++i) lt.trans[24 + 144 + i] = 280 + i;\n  for (i = 0; i < 112; ++i) lt.trans[24 + 144 + 8 + i] = 144 + i;\n\n  /* build fixed distance tree */\n  for (i = 0; i < 5; ++i) dt.table[i] = 0;\n\n  dt.table[5] = 32;\n\n  for (i = 0; i < 32; ++i) dt.trans[i] = i;\n}\n\n/* given an array of code lengths, build a tree */\nvar offs = new Uint16Array(16);\n\nfunction tinf_build_tree(t, lengths, off, num) {\n  var i, sum;\n\n  /* clear code length count table */\n  for (i = 0; i < 16; ++i) t.table[i] = 0;\n\n  /* scan symbol lengths, and sum code length counts */\n  for (i = 0; i < num; ++i) t.table[lengths[off + i]]++;\n\n  t.table[0] = 0;\n\n  /* compute offset table for distribution sort */\n  for (sum = 0, i = 0; i < 16; ++i) {\n    offs[i] = sum;\n    sum += t.table[i];\n  }\n\n  /* create code->symbol translation table (symbols sorted by code) */\n  for (i = 0; i < num; ++i) {\n    if (lengths[off + i]) t.trans[offs[lengths[off + i]]++] = i;\n  }\n}\n\n/* ---------------------- *\n * -- decode functions -- *\n * ---------------------- */\n\n/* get one bit from source stream */\nfunction tinf_getbit(d) {\n  /* check if tag is empty */\n  if (!d.bitcount--) {\n    /* load next tag */\n    d.tag = d.source[d.sourceIndex++];\n    d.bitcount = 7;\n  }\n\n  /* shift bit out of tag */\n  var bit = d.tag & 1;\n  d.tag >>>= 1;\n\n  return bit;\n}\n\n/* read a num bit value from a stream and add base */\nfunction tinf_read_bits(d, num, base) {\n  if (!num)\n    return base;\n\n  while (d.bitcount < 24) {\n    d.tag |= d.source[d.sourceIndex++] << d.bitcount;\n    d.bitcount += 8;\n  }\n\n  var val = d.tag & (0xffff >>> (16 - num));\n  d.tag >>>= num;\n  d.bitcount -= num;\n  return val + base;\n}\n\n/* given a data stream and a tree, decode a symbol */\nfunction tinf_decode_symbol(d, t) {\n  while (d.bitcount < 24) {\n    d.tag |= d.source[d.sourceIndex++] << d.bitcount;\n    d.bitcount += 8;\n  }\n  \n  var sum = 0, cur = 0, len = 0;\n  var tag = d.tag;\n\n  /* get more bits while code value is above sum */\n  do {\n    cur = 2 * cur + (tag & 1);\n    tag >>>= 1;\n    ++len;\n\n    sum += t.table[len];\n    cur -= t.table[len];\n  } while (cur >= 0);\n  \n  d.tag = tag;\n  d.bitcount -= len;\n\n  return t.trans[sum + cur];\n}\n\n/* given a data stream, decode dynamic trees from it */\nfunction tinf_decode_trees(d, lt, dt) {\n  var hlit, hdist, hclen;\n  var i, num, length;\n\n  /* get 5 bits HLIT (257-286) */\n  hlit = tinf_read_bits(d, 5, 257);\n\n  /* get 5 bits HDIST (1-32) */\n  hdist = tinf_read_bits(d, 5, 1);\n\n  /* get 4 bits HCLEN (4-19) */\n  hclen = tinf_read_bits(d, 4, 4);\n\n  for (i = 0; i < 19; ++i) lengths[i] = 0;\n\n  /* read code lengths for code length alphabet */\n  for (i = 0; i < hclen; ++i) {\n    /* get 3 bits code length (0-7) */\n    var clen = tinf_read_bits(d, 3, 0);\n    lengths[clcidx[i]] = clen;\n  }\n\n  /* build code length tree */\n  tinf_build_tree(code_tree, lengths, 0, 19);\n\n  /* decode code lengths for the dynamic trees */\n  for (num = 0; num < hlit + hdist;) {\n    var sym = tinf_decode_symbol(d, code_tree);\n\n    switch (sym) {\n      case 16:\n        /* copy previous code length 3-6 times (read 2 bits) */\n        var prev = lengths[num - 1];\n        for (length = tinf_read_bits(d, 2, 3); length; --length) {\n          lengths[num++] = prev;\n        }\n        break;\n      case 17:\n        /* repeat code length 0 for 3-10 times (read 3 bits) */\n        for (length = tinf_read_bits(d, 3, 3); length; --length) {\n          lengths[num++] = 0;\n        }\n        break;\n      case 18:\n        /* repeat code length 0 for 11-138 times (read 7 bits) */\n        for (length = tinf_read_bits(d, 7, 11); length; --length) {\n          lengths[num++] = 0;\n        }\n        break;\n      default:\n        /* values 0-15 represent the actual code lengths */\n        lengths[num++] = sym;\n        break;\n    }\n  }\n\n  /* build dynamic trees */\n  tinf_build_tree(lt, lengths, 0, hlit);\n  tinf_build_tree(dt, lengths, hlit, hdist);\n}\n\n/* ----------------------------- *\n * -- block inflate functions -- *\n * ----------------------------- */\n\n/* given a stream and two trees, inflate a block of data */\nfunction tinf_inflate_block_data(d, lt, dt) {\n  while (1) {\n    var sym = tinf_decode_symbol(d, lt);\n\n    /* check for end of block */\n    if (sym === 256) {\n      return TINF_OK;\n    }\n\n    if (sym < 256) {\n      d.dest[d.destLen++] = sym;\n    } else {\n      var length, dist, offs;\n      var i;\n\n      sym -= 257;\n\n      /* possibly get more bits from length code */\n      length = tinf_read_bits(d, length_bits[sym], length_base[sym]);\n\n      dist = tinf_decode_symbol(d, dt);\n\n      /* possibly get more bits from distance code */\n      offs = d.destLen - tinf_read_bits(d, dist_bits[dist], dist_base[dist]);\n\n      /* copy match */\n      for (i = offs; i < offs + length; ++i) {\n        d.dest[d.destLen++] = d.dest[i];\n      }\n    }\n  }\n}\n\n/* inflate an uncompressed block of data */\nfunction tinf_inflate_uncompressed_block(d) {\n  var length, invlength;\n  var i;\n  \n  /* unread from bitbuffer */\n  while (d.bitcount > 8) {\n    d.sourceIndex--;\n    d.bitcount -= 8;\n  }\n\n  /* get length */\n  length = d.source[d.sourceIndex + 1];\n  length = 256 * length + d.source[d.sourceIndex];\n\n  /* get one's complement of length */\n  invlength = d.source[d.sourceIndex + 3];\n  invlength = 256 * invlength + d.source[d.sourceIndex + 2];\n\n  /* check length */\n  if (length !== (~invlength & 0x0000ffff))\n    return TINF_DATA_ERROR;\n\n  d.sourceIndex += 4;\n\n  /* copy block */\n  for (i = length; i; --i)\n    d.dest[d.destLen++] = d.source[d.sourceIndex++];\n\n  /* make sure we start next block on a byte boundary */\n  d.bitcount = 0;\n\n  return TINF_OK;\n}\n\n/* inflate stream from source to dest */\nfunction tinf_uncompress(source, dest) {\n  var d = new Data(source, dest);\n  var bfinal, btype, res;\n\n  do {\n    /* read final block flag */\n    bfinal = tinf_getbit(d);\n\n    /* read block type (2 bits) */\n    btype = tinf_read_bits(d, 2, 0);\n\n    /* decompress block */\n    switch (btype) {\n      case 0:\n        /* decompress uncompressed block */\n        res = tinf_inflate_uncompressed_block(d);\n        break;\n      case 1:\n        /* decompress block with fixed huffman trees */\n        res = tinf_inflate_block_data(d, sltree, sdtree);\n        break;\n      case 2:\n        /* decompress block with dynamic huffman trees */\n        tinf_decode_trees(d, d.ltree, d.dtree);\n        res = tinf_inflate_block_data(d, d.ltree, d.dtree);\n        break;\n      default:\n        res = TINF_DATA_ERROR;\n    }\n\n    if (res !== TINF_OK)\n      throw new Error('Data error');\n\n  } while (!bfinal);\n\n  if (d.destLen < d.dest.length) {\n    if (typeof d.dest.slice === 'function')\n      return d.dest.slice(0, d.destLen);\n    else\n      return d.dest.subarray(0, d.destLen);\n  }\n  \n  return d.dest;\n}\n\n/* -------------------- *\n * -- initialization -- *\n * -------------------- */\n\n/* build fixed huffman trees */\ntinf_build_fixed_trees(sltree, sdtree);\n\n/* build extra bits and base tables */\ntinf_build_bits_base(length_bits, length_base, 4, 3);\ntinf_build_bits_base(dist_bits, dist_base, 2, 1);\n\n/* fix a special case */\nlength_bits[28] = 0;\nlength_base[28] = 258;\n\nmodule.exports = tinf_uncompress;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BaseClass = void 0;\nconst fs_1 = __importDefault(require(\"fs\"));\nconst utils_1 = require(\"./utils\");\nclass BaseClass {\n    constructor() {\n        this.options = {};\n        this._renderedTime = 0;\n        this._before = [0, 0];\n    }\n    get hasRendered() {\n        return !!this._canvas;\n    }\n    get canvas() {\n        this._checkHasRendered();\n        return this._canvas;\n    }\n    get renderedTime() {\n        this._checkHasRendered();\n        return this._renderedTime;\n    }\n    get width() {\n        this._checkHasRendered();\n        return this.canvas.width;\n    }\n    get height() {\n        this._checkHasRendered();\n        return this.canvas.height;\n    }\n    render() {\n        return this;\n    }\n    toDataUrl(mineType = \"image/png\", options) {\n        this._checkHasRendered();\n        if (mineType === \"image/png\") {\n            return this.canvas.toDataURL(\"image/png\");\n        }\n        else {\n            return this.canvas.toDataURL(\"image/jpeg\", options === null || options === void 0 ? void 0 : options.quality);\n        }\n    }\n    toBuffer(mineType = \"image/png\", options) {\n        this._checkHasRendered();\n        if (mineType === \"image/png\") {\n            return this.canvas.toBuffer(\"image/png\", options);\n        }\n        else {\n            return this.canvas.toBuffer(\"image/jpeg\", options);\n        }\n    }\n    toFile(filename, mineType = \"\", options) {\n        this._checkHasRendered();\n        if (!mineType) {\n            if (filename.match(/\\.jpg$|\\.jpeg$/i)) {\n                mineType = \"image/jpeg\";\n            }\n            else {\n                mineType = \"image/png\";\n            }\n        }\n        const buffer = this.toBuffer(mineType, options);\n        fs_1.default.writeFileSync(filename, buffer);\n    }\n    toStream(mineType = \"image/png\", options) {\n        this._checkHasRendered();\n        if (mineType === \"image/png\") {\n            return this.canvas.createPNGStream(options);\n        }\n        else {\n            return this.canvas.createJPEGStream(options);\n        }\n    }\n    _checkHasRendered() {\n        if (!this.hasRendered) {\n            throw new Error(`Please run render() first!`);\n        }\n    }\n    _startTimer() {\n        this._before = (0, utils_1.hrtime)();\n    }\n    _endTimer() {\n        const diff = (0, utils_1.hrtime)(this._before);\n        this._renderedTime = diff[0] * 1000 + (diff[1] / 1000000);\n    }\n}\nexports.BaseClass = BaseClass;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.HorizontalImage = void 0;\nconst canvas_1 = require(\"canvas\");\nconst BaseClass_1 = require(\"./BaseClass\");\nconst canvas_2 = require(\"./utils/canvas\");\nclass HorizontalImage extends BaseClass_1.BaseClass {\n    constructor(ultimateTextToImages, options = {}, renderOptions = {}) {\n        super();\n        this.ultimateTextToImages = ultimateTextToImages;\n        this.options = options;\n        this.renderOptions = renderOptions;\n    }\n    render() {\n        this._startTimer();\n        const { backgroundColor } = this.options;\n        const margin = this.options.margin || 0;\n        for (const ultimateTextToImage of this.ultimateTextToImages) {\n            ultimateTextToImage.render();\n        }\n        const width = this.ultimateTextToImages.reduce((a, b) => a + b.width, 0) + margin * 2;\n        const height = this.ultimateTextToImages\n            .reduce((a, b) => Math.max(a, b.height), 0) + margin * 2;\n        this._canvas = new canvas_1.Canvas(width, height);\n        const ctx = this._canvas.getContext(\"2d\");\n        // hook\n        (0, canvas_2.renderHook)(this._canvas, this.renderOptions.preRender);\n        // draw background\n        (0, canvas_2.drawBackgroundColor)(ctx, { color: backgroundColor });\n        let x = margin;\n        let y = 0;\n        for (const ultimateTextToImage of this.ultimateTextToImages) {\n            let valign = this.options.valign;\n            if (ultimateTextToImage.options.nestedValign) {\n                valign = ultimateTextToImage.options.nestedValign;\n            }\n            if (valign === \"bottom\") {\n                y = height - ultimateTextToImage.height - margin;\n            }\n            else if (valign === \"middle\") {\n                y = (height - ultimateTextToImage.height) / 2;\n            }\n            else {\n                y = margin;\n            }\n            ctx.drawImage(ultimateTextToImage.canvas, x, y);\n            x += ultimateTextToImage.width;\n        }\n        // hook\n        (0, canvas_2.renderHook)(this._canvas, this.renderOptions.posRender);\n        this._endTimer();\n        return this;\n    }\n}\nexports.HorizontalImage = HorizontalImage;\n","\"use strict\";\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Measurable = void 0;\nconst canvas_1 = require(\"canvas\");\nconst UnicodeLineBreak_1 = require(\"./UnicodeLineBreak\");\nconst utils_1 = require(\"./utils\");\nclass Measurable {\n    constructor() {\n        this.caches = new Map();\n    }\n    clearCache() {\n        this.caches.clear();\n    }\n    getMeasuredParagraph(options) {\n        const canvas = (0, canvas_1.createCanvas)(100, 100);\n        const ctx = canvas.getContext(\"2d\");\n        return this.testBestMeasuredParagraph(Object.assign({ ctx }, options));\n    }\n    // the logic below may cause the last checking run one more time (but it's ok since things are cached)\n    testBestMeasuredParagraph(options) {\n        const { maxWidth, maxHeight, maxFontSize, minFontSize, fontSize } = options, otherOptions = __rest(options, [\"maxWidth\", \"maxHeight\", \"maxFontSize\", \"minFontSize\", \"fontSize\"]);\n        const measuredParagraph = this.testMeasuredParagraph(Object.assign(Object.assign({}, otherOptions), { maxWidth, fontSize }));\n        const currentHeight = options.useGlyphPadding ? measuredParagraph.boundingHeight : measuredParagraph.height;\n        const currentWidth = options.useGlyphPadding ? measuredParagraph.boundingWidth : measuredParagraph.width;\n        // if height is within range\n        if (currentHeight <= maxHeight && currentWidth <= maxWidth) {\n            // we still can try to do searching\n            if (options.maxFontSize > measuredParagraph.fontSize) {\n                const newFontSize = Math.ceil((options.fontSize + options.maxFontSize) / 2);\n                return this.testBestMeasuredParagraph(Object.assign(Object.assign({}, options), { fontSize: newFontSize, minFontSize: measuredParagraph.fontSize }));\n            }\n            else {\n                return measuredParagraph;\n            }\n        }\n        else {\n            // if we have smaller available font size\n            if (options.minFontSize < measuredParagraph.fontSize) {\n                // we try an Log(N) guess\n                const newFontSize = Math.floor((options.fontSize + options.minFontSize) / 2);\n                return this.testBestMeasuredParagraph(Object.assign(Object.assign({}, options), { fontSize: newFontSize, maxFontSize: measuredParagraph.fontSize - 1 }));\n            }\n            else {\n                return measuredParagraph;\n            }\n        }\n    }\n    // give information of all the lines\n    testMeasuredParagraph(options) {\n        const { ctx, text, noAutoWrap, fontFamily, fontStyle, fontWeight, fontSize, lineHeight, lineHeightMultiplier, autoWrapLineHeight, autoWrapLineHeightMultiplier, useGlyphPadding, } = options;\n        const measuredWords = this.testMeasureWords({ ctx, text, fontStyle, fontWeight, fontSize, fontFamily });\n        const maxWidth = options.maxWidth;\n        // prepare settings\n        const finalLineHeight = Math.round(typeof lineHeight === \"number\" ? lineHeight :\n            (typeof lineHeightMultiplier === \"number\" ? fontSize * lineHeightMultiplier : fontSize));\n        const finalAutoWrapLineHeight = Math.round(typeof autoWrapLineHeight === \"number\" ? autoWrapLineHeight :\n            (typeof autoWrapLineHeightMultiplier === \"number\" ? fontSize * autoWrapLineHeightMultiplier : finalLineHeight));\n        // find space width first\n        const measuredSpace = this.testMeasuredWord(Object.assign(Object.assign({}, options), { text: \" \" }));\n        const spaceWidth = measuredSpace.width;\n        // prepare canvas\n        let measuredLine = {\n            text: \"\",\n            width: 0,\n            paddingTop: -fontSize,\n            paddingBottom: 0,\n            paddingLeft: 0,\n            paddingRight: 0,\n            nextLineHeight: 0,\n            measuredWords: [],\n        };\n        const measuredParagraph = {\n            text,\n            width: 0,\n            height: 0,\n            fontSize,\n            fontFamily,\n            fontStyle,\n            fontWeight,\n            spaceWidth,\n            boundingHeight: 0,\n            boundingWidth: 0,\n            paddingTop: 0,\n            paddingBottom: 0,\n            paddingLeft: 0,\n            paddingRight: 0,\n            measuredLines: [],\n        };\n        let lastMeasuredWord;\n        for (const measuredWord of measuredWords) {\n            // we get the last word spacing information\n            let lastWordTotalSpaceWidth = 0;\n            let lastWordSpaceCount = 0;\n            if (lastMeasuredWord && !lastMeasuredWord.hasLineBreak) {\n                lastWordTotalSpaceWidth = lastMeasuredWord.endingSpaceCount * spaceWidth;\n                lastWordSpaceCount = lastMeasuredWord.endingSpaceCount;\n            }\n            // choose which width for calculation\n            let currentWidth = measuredLine.width + lastWordTotalSpaceWidth + measuredWord.width;\n            if (useGlyphPadding) {\n                currentWidth += measuredWord.paddingLeft + measuredWord.paddingRight;\n            }\n            // if we have auto Wrap & make sure each line within max width\n            if (!noAutoWrap && currentWidth > maxWidth) {\n                // we go into another line the line contains something already\n                if (measuredLine.text) {\n                    measuredLine.nextLineHeight = finalAutoWrapLineHeight;\n                    measuredParagraph.measuredLines.push(measuredLine);\n                }\n                // create new line\n                measuredLine = {\n                    text: measuredWord.text,\n                    width: measuredWord.width,\n                    paddingTop: measuredWord.paddingTop,\n                    paddingBottom: measuredWord.paddingBottom,\n                    paddingLeft: measuredWord.paddingLeft,\n                    paddingRight: measuredWord.paddingRight,\n                    nextLineHeight: 0,\n                    measuredWords: [],\n                };\n            }\n            else {\n                // add the word\n                measuredLine.text += (\" \".repeat(lastWordSpaceCount) + measuredWord.text);\n                measuredLine.paddingTop = Math.max(measuredLine.paddingTop, measuredWord.paddingTop);\n                measuredLine.paddingBottom = Math.max(measuredLine.paddingBottom, measuredWord.paddingBottom);\n                if (measuredLine.width === 0) {\n                    measuredLine.paddingLeft = measuredWord.paddingLeft;\n                }\n                measuredLine.paddingRight = measuredWord.paddingRight;\n                measuredLine.width = measuredLine.width + lastWordTotalSpaceWidth + measuredWord.width;\n                measuredLine.measuredWords.push(measuredWord);\n            }\n            /// if it's not last word, do some further processing\n            if (!measuredWord.isLastWord) {\n                if (measuredWord.hasLineBreak) {\n                    measuredLine.nextLineHeight = finalLineHeight;\n                    measuredParagraph.measuredLines.push(measuredLine);\n                    measuredLine = {\n                        text: \"\",\n                        width: 0,\n                        paddingTop: -fontSize,\n                        paddingBottom: 0,\n                        paddingLeft: 0,\n                        paddingRight: 0,\n                        nextLineHeight: 0,\n                        measuredWords: [],\n                    };\n                }\n            }\n            lastMeasuredWord = measuredWord;\n        }\n        // if we current measuredLine has width, add it\n        if (measuredLine.width) {\n            measuredParagraph.measuredLines.push(measuredLine);\n        }\n        // make sure we have lines\n        // compute some final params\n        const totalLines = measuredParagraph.measuredLines.length;\n        if (totalLines) {\n            measuredParagraph.width = measuredParagraph.measuredLines\n                .reduce((a, b) => Math.max(a, b.width), 0);\n            measuredParagraph.height = measuredParagraph.measuredLines\n                .reduce((a, b) => a + b.nextLineHeight, measuredParagraph.fontSize);\n            const paddingTop = measuredParagraph.measuredLines[0].paddingTop;\n            const paddingBottom = measuredParagraph.measuredLines[totalLines - 1].paddingBottom;\n            measuredParagraph.paddingTop = paddingTop;\n            measuredParagraph.paddingBottom = paddingBottom;\n            measuredParagraph.boundingHeight = measuredParagraph.height + paddingTop + paddingBottom;\n            measuredParagraph.boundingWidth = measuredParagraph.measuredLines.reduce((a, b) => Math.max(a, b.width + b.paddingLeft + b.paddingRight), 0);\n            measuredParagraph.paddingLeft = measuredParagraph.measuredLines.reduce((a, b) => Math.max(a, b.paddingLeft), -fontSize);\n            measuredParagraph.paddingRight = measuredParagraph.measuredLines.reduce((a, b) => Math.max(a, b.paddingRight), -fontSize);\n        }\n        return measuredParagraph;\n    }\n    // give information for all the words\n    testMeasureWords(options) {\n        const measuredWords = [];\n        const unicodeLineBreak = new UnicodeLineBreak_1.UnicodeLineBreak(options.text);\n        for (const item of unicodeLineBreak) {\n            const word = item.word;\n            const trimmedWord = word.trimRight();\n            const measuredWord = this.testMeasuredWord(Object.assign(Object.assign({}, options), { text: trimmedWord }));\n            measuredWords.push({\n                text: trimmedWord,\n                width: measuredWord.width,\n                paddingTop: measuredWord.paddingTop,\n                paddingBottom: measuredWord.paddingBottom,\n                paddingLeft: measuredWord.paddingLeft,\n                paddingRight: measuredWord.paddingRight,\n                endingSpaceCount: word.length - trimmedWord.length,\n                isLastWord: item.isLastWord,\n                hasLineBreak: item.hasLineBreak,\n            });\n        }\n        return measuredWords;\n    }\n    testMeasuredWord(options) {\n        const { ctx, text, fontStyle, fontWeight, fontSize, fontFamily } = options;\n        const fontString = (0, utils_1.getFontString)({ fontStyle, fontWeight, fontSize, fontFamily });\n        ctx.font = fontString;\n        // create font family map if not exist\n        if (!this.caches.has(fontString)) {\n            this.caches.set(fontString, new Map());\n        }\n        // create font size map if not exist\n        const fontFamilyMap = this.caches.get(fontString);\n        if (!fontFamilyMap.has(fontSize)) {\n            fontFamilyMap.set(fontSize, new Map());\n        }\n        // calculate the word width\n        const fontSizeMap = fontFamilyMap.get(fontSize);\n        if (!fontSizeMap.has(text)) {\n            const measureText = ctx.measureText(text);\n            let paddingLeft = measureText.actualBoundingBoxLeft;\n            let paddingRight = measureText.actualBoundingBoxRight - measureText.width;\n            // Special Handling: if this is reversed type of language\n            if (measureText.width > 0 &&\n                measureText.actualBoundingBoxLeft / measureText.width > 0.8 &&\n                measureText.actualBoundingBoxRight / measureText.width < 0.2) {\n                paddingLeft = measureText.actualBoundingBoxLeft - measureText.width;\n                paddingRight = measureText.actualBoundingBoxRight;\n            }\n            // console.log(text, measureText);\n            // console.log(\"measure\", `${fontStyle}, left: ${paddingLeft}, right: ${paddingRight}, ${text}`);\n            fontSizeMap.set(text, {\n                text,\n                width: measureText.width,\n                paddingTop: measureText.actualBoundingBoxAscent - fontSize,\n                paddingBottom: measureText.actualBoundingBoxDescent,\n                paddingLeft,\n                paddingRight,\n            });\n        }\n        return fontSizeMap.get(text);\n    }\n}\nexports.Measurable = Measurable;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.UltimateTextToImage = void 0;\nconst canvas_1 = require(\"canvas\");\nconst BaseClass_1 = require(\"./BaseClass\");\nconst Measurable_1 = require(\"./Measurable\");\nconst canvas_2 = require(\"./utils/canvas\");\nclass UltimateTextToImage extends BaseClass_1.BaseClass {\n    constructor(text, options = {}, renderOptions = {}) {\n        super();\n        this.text = text;\n        this.options = options;\n        this.renderOptions = renderOptions;\n        this._defaultOptions = {\n            width: undefined,\n            height: undefined,\n            maxWidth: undefined,\n            maxHeight: undefined,\n            noAutoWrap: false,\n            fontFamily: \"Arial\",\n            fontWeight: false,\n            fontStyle: false,\n            fontSize: 24,\n            minFontSize: undefined,\n            fontColor: \"#333333\",\n            strokeSize: 0,\n            strokeColor: \"#000000\",\n            lineHeight: undefined,\n            lineHeightMultiplier: undefined,\n            autoWrapLineHeight: undefined,\n            autoWrapLineHeightMultiplier: undefined,\n            margin: 0,\n            marginLeft: undefined,\n            marginTop: undefined,\n            marginRight: undefined,\n            marginBottom: undefined,\n            useGlyphPadding: true,\n            chopOverflow: false,\n            align: \"left\",\n            valign: \"top\",\n            alignToCenterIfHeightLE: 0,\n            alignToCenterIfLinesLE: 0,\n            borderColor: \"#000000\",\n            borderSize: 0,\n            backgroundColor: \"\",\n            underlineSize: 0,\n            underlineColor: \"\",\n            images: [],\n            nestedAlign: undefined,\n            nestedValign: undefined,\n        };\n    }\n    get measuredParagraph() {\n        this._checkHasRendered();\n        return this._measuredParagraph;\n    }\n    render() {\n        this._startTimer();\n        this._createCanvas();\n        this._endTimer();\n        return this;\n    }\n    // draw the image based on various options\n    _createCanvas() {\n        const text = this.text;\n        // merge default options\n        const options = Object.assign({}, this._defaultOptions, this.options);\n        // prepare all variables\n        const { height, width, noAutoWrap, fontFamily, fontStyle, fontWeight, fontSize, chopOverflow, useGlyphPadding, underlineSize, underlineColor, images, } = options;\n        let { maxWidth, maxHeight, minFontSize } = options;\n        // work on default values\n        maxHeight = typeof maxHeight === \"number\" ? maxHeight : (typeof height === \"number\" ? height : UltimateTextToImage.maxSize);\n        maxWidth = typeof maxWidth === \"number\" ? maxWidth : (typeof width === \"number\" ? width : UltimateTextToImage.maxSize);\n        // update max size\n        maxWidth = Math.max(width || 1, maxWidth);\n        maxHeight = Math.max(height || 1, maxHeight);\n        minFontSize = typeof minFontSize === \"number\" ? minFontSize : options.fontSize;\n        const marginLeft = typeof options.marginLeft === \"number\" ? options.marginLeft : options.margin;\n        const marginTop = typeof options.marginTop === \"number\" ? options.marginTop : options.margin;\n        const marginRight = typeof options.marginRight === \"number\" ? options.marginRight : options.margin;\n        const marginBottom = typeof options.marginBottom === \"number\" ? options.marginBottom : options.margin;\n        // find the best measured paragraph\n        const measuredParagraph = UltimateTextToImage.measurable.getMeasuredParagraph({\n            text,\n            maxWidth: maxWidth - marginLeft - marginRight,\n            maxHeight: maxHeight - marginTop - marginBottom,\n            noAutoWrap,\n            fontFamily,\n            fontStyle,\n            fontWeight,\n            maxFontSize: fontSize,\n            minFontSize,\n            fontSize,\n            useGlyphPadding,\n            lineHeight: options.lineHeight,\n            lineHeightMultiplier: options.lineHeightMultiplier,\n            autoWrapLineHeight: options.autoWrapLineHeight,\n            autoWrapLineHeightMultiplier: options.autoWrapLineHeightMultiplier,\n        });\n        // prepared update varaibles\n        const finalFontSize = measuredParagraph.fontSize;\n        // update the alignments\n        let finalValign = options.valign;\n        let finalAlign = options.align;\n        const desiredCanvasHeight = measuredParagraph.height + marginTop + marginBottom;\n        const desiredCanvasBoundingHeight = measuredParagraph.boundingHeight + marginTop + marginBottom;\n        const desiredCanvasWidth = measuredParagraph.width + marginLeft + marginRight;\n        const desiredCanvasBoundingWidth = measuredParagraph.boundingWidth + marginLeft + marginRight;\n        let finalHeight = Math.max(typeof height === \"number\" ? height : desiredCanvasHeight, Math.min(maxHeight, desiredCanvasHeight));\n        let finalWidth = Math.max(typeof width === \"number\" ? width : desiredCanvasWidth, Math.min(maxWidth, desiredCanvasWidth));\n        if (options.alignToCenterIfHeightLE && measuredParagraph.height <= options.alignToCenterIfHeightLE) {\n            finalValign = \"middle\";\n            finalAlign = \"center\";\n        }\n        if (options.alignToCenterIfLinesLE && measuredParagraph.measuredLines.length <= options.alignToCenterIfLinesLE) {\n            finalValign = \"middle\";\n            finalAlign = \"center\";\n        }\n        // if we want more precise spacing\n        if (useGlyphPadding) {\n            finalHeight = Math.max(typeof height === \"number\" ? height : desiredCanvasBoundingHeight, Math.min(maxHeight, desiredCanvasBoundingHeight));\n            finalWidth = Math.max(typeof width === \"number\" ? width : desiredCanvasBoundingWidth, Math.min(maxWidth, desiredCanvasBoundingWidth));\n        }\n        // update the object values\n        finalWidth = Math.max(1, finalWidth);\n        finalHeight = Math.max(1, finalHeight);\n        this._measuredParagraph = measuredParagraph;\n        this._canvas = (0, canvas_1.createCanvas)(finalWidth, finalHeight);\n        const ctx = this._canvas.getContext(\"2d\");\n        // hook\n        (0, canvas_2.renderHook)(this._canvas, this.renderOptions.preRender);\n        // draw images\n        (0, canvas_2.drawImages)(ctx, { width: finalWidth, height: finalHeight, layer: -1, images });\n        // draw background\n        (0, canvas_2.drawBackgroundColor)(ctx, { color: options.backgroundColor });\n        // draw border\n        (0, canvas_2.drawBorder)(ctx, { color: options.borderColor, size: options.borderSize });\n        // draw images\n        (0, canvas_2.drawImages)(ctx, { width: finalWidth, height: finalHeight, layer: 0, images });\n        // draw texts\n        (0, canvas_2.drawTexts)(ctx, {\n            measuredParagraph,\n            width: finalWidth,\n            height: finalHeight,\n            fontFamily,\n            fontStyle: options.fontStyle,\n            fontWeight: options.fontWeight,\n            fontSize: finalFontSize,\n            fontColor: options.fontColor,\n            strokeSize: options.strokeSize,\n            strokeColor: options.strokeColor,\n            valign: finalValign,\n            align: finalAlign,\n            // margin: options.margin,\n            marginLeft,\n            marginTop,\n            marginRight,\n            marginBottom,\n            chopOverflow,\n            useGlyphPadding,\n            underlineSize,\n            underlineColor,\n        });\n        (0, canvas_2.drawImages)(ctx, { width: finalWidth, height: finalHeight, layer: 1, images });\n        // hook\n        (0, canvas_2.renderHook)(this._canvas, this.renderOptions.posRender);\n        return this._canvas;\n    }\n}\nexports.UltimateTextToImage = UltimateTextToImage;\nUltimateTextToImage.measurable = new Measurable_1.Measurable();\nUltimateTextToImage.maxSize = 2 << 14 - 1;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.UnicodeLineBreak = void 0;\n// tslint:disable-next-line:no-var-requires variable-name\nconst LineBreakNext = require(\"linebreak-next\");\nclass UnicodeLineBreak {\n    constructor(text) {\n        this.text = text;\n        //\n    }\n    getResults() {\n        const results = [];\n        for (const item of this) {\n            results.push(item);\n        }\n        return results;\n    }\n    [Symbol.iterator]() {\n        const text = this.text;\n        const lineBreaker = new LineBreakNext(text);\n        let last = 0;\n        return {\n            next: () => {\n                const bk = lineBreaker.nextBreak();\n                if (!bk) {\n                    return { value: undefined, done: true };\n                }\n                const word = text\n                    .slice(last, bk.position)\n                    .replace(/(\\r?\\n)*$/, \"\");\n                const index = last;\n                const isLastWord = bk.position === text.length;\n                last = bk.position;\n                return { value: { word, index, hasLineBreak: bk.required, isLastWord }, done: false };\n            },\n        };\n    }\n}\nexports.UnicodeLineBreak = UnicodeLineBreak;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.VerticalImage = void 0;\nconst canvas_1 = require(\"canvas\");\nconst BaseClass_1 = require(\"./BaseClass\");\nconst canvas_2 = require(\"./utils/canvas\");\nclass VerticalImage extends BaseClass_1.BaseClass {\n    constructor(ultimateTextToImages, options = {}, renderOptions = {}) {\n        super();\n        this.ultimateTextToImages = ultimateTextToImages;\n        this.options = options;\n        this.renderOptions = renderOptions;\n    }\n    render() {\n        this._startTimer();\n        const { backgroundColor } = this.options;\n        const margin = this.options.margin || 0;\n        for (const ultimateTextToImage of this.ultimateTextToImages) {\n            ultimateTextToImage.render();\n        }\n        const width = this.ultimateTextToImages\n            .reduce((a, b) => Math.max(a, b.width), 0) + margin * 2;\n        const height = this.ultimateTextToImages.reduce((a, b) => a + b.height, 0) + margin * 2;\n        this._canvas = new canvas_1.Canvas(width, height);\n        const ctx = this._canvas.getContext(\"2d\");\n        // hook\n        (0, canvas_2.renderHook)(this._canvas, this.renderOptions.preRender);\n        // draw background\n        (0, canvas_2.drawBackgroundColor)(ctx, { color: backgroundColor });\n        let x = 0;\n        let y = margin;\n        for (const ultimateTextToImage of this.ultimateTextToImages) {\n            let align = this.options.align;\n            if (ultimateTextToImage.options.nestedAlign) {\n                align = ultimateTextToImage.options.nestedAlign;\n            }\n            if (align === \"right\") {\n                x = width - ultimateTextToImage.width - margin;\n            }\n            else if (align === \"center\") {\n                x = (width - ultimateTextToImage.width) / 2;\n            }\n            else {\n                x = margin;\n            }\n            ctx.drawImage(ultimateTextToImage.canvas, x, y);\n            y += ultimateTextToImage.height;\n        }\n        // hook\n        (0, canvas_2.renderHook)(this._canvas, this.renderOptions.posRender);\n        this._endTimer();\n        return this;\n    }\n}\nexports.VerticalImage = VerticalImage;\n","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getCanvasImage = void 0;\nconst canvas = __importStar(require(\"canvas\"));\nconst simple_get_1 = require(\"simple-get\");\nconst getCanvasImage = (options) => __awaiter(void 0, void 0, void 0, function* () {\n    if (options.buffer) {\n        const newBase64 = `data:image/jpg;base64,${options.buffer.toString(\"base64\")}`;\n        return yield canvas.loadImage(newBase64);\n    }\n    else if (options.arrayBuffer) {\n        const newBase64 = `data:image/jpg;base64,${Buffer.from(options.arrayBuffer).toString(\"base64\")}`;\n        return yield canvas.loadImage(newBase64);\n    }\n    else if (options.url) {\n        try {\n            const buffer = yield new Promise((resolve, reject) => {\n                (0, simple_get_1.concat)(options.url, (err, res, data) => {\n                    if (err) {\n                        return reject(err);\n                    }\n                    if (res.statusCode !== 200) {\n                        return reject(new Error(\"Invalid Image\"));\n                    }\n                    resolve(data);\n                });\n            });\n            const newBase64 = `data:image/jpg;base64,${buffer.toString(\"base64\")}`;\n            return yield canvas.loadImage(newBase64);\n        }\n        catch (err) {\n            // ignore error\n        }\n        yield new Promise(resolve => setTimeout(resolve, 1000));\n    }\n    else if (options.base64) {\n        const base64 = options.base64;\n        if (base64.indexOf(\"data:\") === 0) {\n            return yield canvas.loadImage(base64);\n        }\n        else {\n            const newBase64 = `data:image/jpg;base64,${base64}`;\n            return yield canvas.loadImage(newBase64);\n        }\n    }\n    throw new Error(\"Invalid Image\");\n});\nexports.getCanvasImage = getCanvasImage;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.UnicodeLineBreak = exports.VerticalImage = exports.HorizontalImage = exports.UltimateTextToImage = exports.registerFont = exports.getCanvasImage = void 0;\nconst getCanvasImage_1 = require(\"./getCanvasImage\");\nObject.defineProperty(exports, \"getCanvasImage\", { enumerable: true, get: function () { return getCanvasImage_1.getCanvasImage; } });\nconst HorizontalImage_1 = require(\"./HorizontalImage\");\nObject.defineProperty(exports, \"HorizontalImage\", { enumerable: true, get: function () { return HorizontalImage_1.HorizontalImage; } });\nconst registerFont_1 = require(\"./registerFont\");\nObject.defineProperty(exports, \"registerFont\", { enumerable: true, get: function () { return registerFont_1.registerFont; } });\nconst UltimateTextToImage_1 = require(\"./UltimateTextToImage\");\nObject.defineProperty(exports, \"UltimateTextToImage\", { enumerable: true, get: function () { return UltimateTextToImage_1.UltimateTextToImage; } });\nconst UnicodeLineBreak_1 = require(\"./UnicodeLineBreak\");\nObject.defineProperty(exports, \"UnicodeLineBreak\", { enumerable: true, get: function () { return UnicodeLineBreak_1.UnicodeLineBreak; } });\nconst VerticalImage_1 = require(\"./VerticalImage\");\nObject.defineProperty(exports, \"VerticalImage\", { enumerable: true, get: function () { return VerticalImage_1.VerticalImage; } });\n","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.registerFont = void 0;\nconst canvas = __importStar(require(\"canvas\"));\nconst crypto_1 = __importDefault(require(\"crypto\"));\nconst registerFont = (filename, options) => {\n    const family = (options === null || options === void 0 ? void 0 : options.family) || generateRandomString(16);\n    const weight = typeof (options === null || options === void 0 ? void 0 : options.weight) === \"boolean\" ? (options.weight ? \"bold\" : undefined) : ((options === null || options === void 0 ? void 0 : options.weight) ? options.weight.toString() : undefined);\n    const style = typeof (options === null || options === void 0 ? void 0 : options.style) === \"boolean\" ? (options.style ? \"italic\" : undefined) : ((options === null || options === void 0 ? void 0 : options.style) ? options.style : undefined);\n    canvas.registerFont(filename, { family, weight, style });\n};\nexports.registerFont = registerFont;\nfunction generateRandomString(length) {\n    const value = crypto_1.default.randomBytes(Math.ceil(length / 2)).toString(\"hex\");\n    return value.substr(0, length);\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.drawTexts = exports.drawImages = exports.drawBorder = exports.drawBackgroundColor = exports.renderHook = void 0;\nconst canvas_1 = require(\"canvas\");\nconst index_1 = require(\"./index\");\n/** @internal */\nfunction renderHook(canvas, hook) {\n    if (hook) {\n        hook(canvas);\n    }\n}\nexports.renderHook = renderHook;\n/** @internal */\nfunction drawBackgroundColor(ctx, options) {\n    if (options.color || typeof options.color === \"number\") {\n        const { width, height } = ctx.canvas;\n        ctx.fillStyle = (0, index_1.parseColorString)(options.color);\n        ctx.fillRect(0, 0, width, height);\n    }\n}\nexports.drawBackgroundColor = drawBackgroundColor;\n/** @internal */\nfunction drawBorder(ctx, options) {\n    if (options.size && (options.color || typeof options.color === \"number\")) {\n        const { width, height } = ctx.canvas;\n        ctx.strokeStyle = (0, index_1.parseColorString)(options.color);\n        // multiple by 2 since it's align to center\n        ctx.lineWidth = options.size * 2;\n        ctx.strokeRect(0, 0, width, height);\n    }\n}\nexports.drawBorder = drawBorder;\n/** @internal */\nfunction drawImages(ctx, options) {\n    const { images } = options;\n    const canvasWidth = options.width | 0;\n    const canvasHeight = options.height | 0;\n    for (const imageSetting of images) {\n        const { canvasImage, repeat, sx, sy, tx, ty } = imageSetting;\n        const layer = imageSetting.layer || 0;\n        // make sure it's a valid image\n        if (!canvasImage || !canvasImage.width || !canvasImage.height) {\n            continue;\n        }\n        // check the layer\n        if (layer !== options.layer) {\n            continue;\n        }\n        // prepare all dimensions\n        const imageWidth = canvasImage.width;\n        const imageHeight = canvasImage.height;\n        const tempWidth = imageSetting.width === \"image\" ? imageWidth : (imageSetting.width === \"canvas\" ? canvasWidth : (imageSetting.width || 0));\n        const tempHeight = imageSetting.height === \"image\" ? imageHeight : (imageSetting.height === \"canvas\" ? canvasHeight : (imageSetting.height || 0));\n        const x = typeof sx === \"number\" ? (sx >= 0 ? sx : canvasWidth + sx) : (imageSetting.x || 0);\n        const y = typeof sy === \"number\" ? (sy >= 0 ? sy : canvasHeight + sy) : (imageSetting.y || 0);\n        const width = typeof tx === \"number\" ? (tx > 0 ? tx : canvasWidth + tx) - x : (tempWidth || canvasWidth - x);\n        const height = typeof ty === \"number\" ? (ty > 0 ? ty : canvasHeight + ty) - y : (tempHeight || canvasHeight - y);\n        // skip if invalid\n        if (width <= 0 || height <= 0) {\n            continue;\n        }\n        if (!repeat || repeat === \"none\" || repeat === \"topLeft\") {\n            ctx.drawImage(canvasImage, 0, 0, width, height, x, y, width, height);\n        }\n        else if (repeat === \"topCenter\") {\n            const sx1 = (imageWidth - width) / 2;\n            ctx.drawImage(canvasImage, sx1, 0, width, height, x, y, width, height);\n        }\n        else if (repeat === \"topRight\") {\n            const sx1 = imageWidth - width;\n            ctx.drawImage(canvasImage, sx1, 0, width, height, x, y, width, height);\n        }\n        else if (repeat === \"middleLeft\") {\n            const sy1 = (imageHeight - height) / 2;\n            ctx.drawImage(canvasImage, 0, sy1, width, height, x, y, width, height);\n        }\n        else if (repeat === \"center\") {\n            const sx1 = (imageWidth - width) / 2;\n            const sy1 = (imageHeight - height) / 2;\n            ctx.drawImage(canvasImage, sx1, sy1, width, height, x, y, width, height);\n        }\n        else if (repeat === \"middleRight\") {\n            const sx1 = imageWidth - width;\n            const sy1 = (imageHeight - height) / 2;\n            ctx.drawImage(canvasImage, sx1, sy1, width, height, x, y, width, height);\n        }\n        else if (repeat === \"bottomLeft\") {\n            const sy1 = imageHeight - height;\n            ctx.drawImage(canvasImage, 0, sy1, width, height, x, y, width, height);\n        }\n        else if (repeat === \"bottomCenter\") {\n            const sx1 = (imageWidth - width) / 2;\n            const sy1 = imageHeight - height;\n            ctx.drawImage(canvasImage, sx1, sy1, width, height, x, y, width, height);\n        }\n        else if (repeat === \"bottomRight\") {\n            const sx1 = imageWidth - width;\n            const sy1 = imageHeight - height;\n            ctx.drawImage(canvasImage, sx1, sy1, width, height, x, y, width, height);\n        }\n        else if (repeat === \"fit\") {\n            ctx.drawImage(canvasImage, 0, 0, imageWidth, imageHeight, x, y, width, height);\n        }\n        else if (repeat === \"fitX\") {\n            const finalImageHeight = Math.min(height, imageHeight);\n            ctx.drawImage(canvasImage, 0, 0, imageWidth, finalImageHeight, x, y, width, finalImageHeight);\n        }\n        else if (repeat === \"fitY\") {\n            const finalImageWidth = Math.min(x + width - x, imageWidth);\n            ctx.drawImage(canvasImage, 0, 0, finalImageWidth, imageHeight, x, y, finalImageWidth, height);\n        }\n        else if (repeat === \"repeat\") {\n            for (let y1 = y; y1 < y + height; y1 += imageHeight) {\n                for (let x1 = x; x1 < x + width; x1 += imageWidth) {\n                    const finalImageWidth = Math.min(x + width - x1, imageWidth);\n                    const finalImageHeight = Math.min(y + height - y1, imageHeight);\n                    ctx.drawImage(canvasImage, 0, 0, finalImageWidth, finalImageHeight, x1, y1, finalImageWidth, finalImageHeight);\n                }\n            }\n        }\n        else if (repeat === \"repeatY\") {\n            for (let y1 = y; y1 < y + height; y1 += imageHeight) {\n                const finalImageWidth = Math.min(x + width - x, imageWidth);\n                const finalImageHeight = Math.min(y + height - y1, imageHeight);\n                ctx.drawImage(canvasImage, 0, 0, finalImageWidth, finalImageHeight, x, y1, finalImageWidth, finalImageHeight);\n            }\n        }\n        else if (repeat === \"repeatX\") {\n            for (let x1 = x; x1 < x + width; x1 += imageWidth) {\n                const finalImageWidth = Math.min(x + width - x1, imageWidth);\n                const finalImageHeight = Math.min(y + height - y, imageHeight);\n                ctx.drawImage(canvasImage, 0, 0, finalImageWidth, finalImageHeight, x1, y, finalImageWidth, finalImageHeight);\n            }\n        }\n    }\n}\nexports.drawImages = drawImages;\n/** @internal */\nfunction drawTexts(ctx, options) {\n    const { measuredParagraph, width, height, fontFamily, fontStyle, fontWeight, fontSize, fontColor, strokeSize, strokeColor, valign, align, marginLeft, marginTop, marginRight, marginBottom, chopOverflow, useGlyphPadding, underlineSize, underlineColor, } = options;\n    // return immediately if nothing to draw\n    if (!measuredParagraph.measuredLines.length) {\n        return;\n    }\n    const textCanvasWidth = useGlyphPadding ? measuredParagraph.boundingWidth : measuredParagraph.width;\n    const textCanvasHeight = useGlyphPadding ? measuredParagraph.boundingHeight : measuredParagraph.height;\n    // we add extra height (just fontSize) to make sure we able to draw characters with boxDescent\n    const renderMargin = Math.round(fontSize / 2);\n    const textCanvas = (0, canvas_1.createCanvas)(textCanvasWidth + renderMargin * 2, textCanvasHeight + renderMargin * 2);\n    const parsedFontColor = (0, index_1.parseColorString)(fontColor);\n    const parsedUnderlineStyle = (0, index_1.parseColorString)(underlineColor);\n    const textCtx = textCanvas.getContext(\"2d\");\n    textCtx.font = (0, index_1.getFontString)({ fontStyle, fontWeight, fontSize, fontFamily });\n    // we draw everything cuz align may need to display different parts (this can be optimized a bit if necessary)\n    let y = useGlyphPadding ? fontSize + measuredParagraph.measuredLines[0].paddingTop : fontSize;\n    for (const measuredLine of measuredParagraph.measuredLines) {\n        let x = 0;\n        if (align === \"center\") {\n            x = (textCanvasWidth - measuredLine.width) / 2;\n            if (useGlyphPadding) {\n                x = (textCanvasWidth - (measuredLine.width - measuredLine.paddingLeft + measuredLine.paddingRight)) / 2;\n            }\n        }\n        else if (align === \"right\") {\n            x = textCanvasWidth - measuredLine.width;\n            if (useGlyphPadding) {\n                x = textCanvasWidth - measuredLine.width - measuredParagraph.paddingRight;\n            }\n        }\n        else {\n            if (useGlyphPadding) {\n                x = measuredParagraph.paddingLeft;\n            }\n        }\n        // draw underline\n        if (underlineSize) {\n            textCtx.fillStyle = parsedUnderlineStyle;\n            textCtx.fillRect(x + renderMargin, y + renderMargin, measuredLine.width, underlineSize);\n        }\n        // draw the text\n        textCtx.fillStyle = parsedFontColor;\n        textCtx.fillText(measuredLine.text, x + renderMargin, y + renderMargin);\n        // draw the stoke if have\n        if (strokeSize) {\n            textCtx.strokeStyle = (0, index_1.parseColorString)(strokeColor);\n            textCtx.lineWidth = strokeSize;\n            textCtx.strokeText(measuredLine.text, x + renderMargin, y + renderMargin);\n        }\n        // advance y\n        y += (measuredLine.nextLineHeight);\n    }\n    // // if we want more precise spacing\n    let sx = 0;\n    let sy = 0;\n    let tx = 0;\n    let ty = 0;\n    let sWidth = width;\n    let sHeight = height;\n    // measure what to display for align\n    if (align === \"right\") {\n        sx = textCanvasWidth - width + marginRight;\n        if (chopOverflow) {\n            tx += marginLeft;\n            sx += marginLeft;\n            sWidth = width - marginLeft - marginRight;\n        }\n    }\n    else if (align === \"center\") {\n        sx = (textCanvasWidth - width - marginLeft + marginRight) / 2;\n        if (chopOverflow) {\n            tx += marginLeft;\n            sx += marginLeft;\n            sWidth = width - marginLeft - marginRight;\n        }\n    }\n    else { // left\n        sx = -marginLeft;\n        if (chopOverflow) {\n            sWidth = width - marginRight;\n        }\n    }\n    // measure what to display for valign\n    if (valign === \"bottom\") {\n        sy = textCanvasHeight - height + marginBottom;\n        if (chopOverflow) {\n            ty += marginTop;\n            sy += marginTop;\n            sHeight = height - marginTop - marginBottom;\n        }\n    }\n    else if (valign === \"middle\") {\n        sy = (textCanvasHeight - height - marginTop + marginBottom) / 2;\n        if (chopOverflow) {\n            ty += marginTop;\n            sy += marginTop;\n            sHeight = height - marginTop - marginBottom;\n        }\n    }\n    else { // top\n        sy = -marginTop;\n        if (chopOverflow) {\n            sHeight = height - marginBottom;\n        }\n    }\n    // draw the image\n    ctx.drawImage(textCanvas, sx + renderMargin, sy + renderMargin, sWidth, sHeight, tx, ty, sWidth, sHeight);\n}\nexports.drawTexts = drawTexts;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.hrtime = exports.parseHexTo255 = exports.parseColor = exports.parseColorString = exports.getFontString = void 0;\nconst getFontString = (options) => {\n    const styleStrings = [];\n    if (options.fontStyle) {\n        if (typeof options.fontStyle === \"boolean\") {\n            styleStrings.push(`italic`);\n        }\n        else {\n            styleStrings.push(options.fontStyle);\n        }\n    }\n    if (options.fontWeight) {\n        if (typeof options.fontWeight === \"boolean\") {\n            styleStrings.push(`bold`);\n        }\n        else {\n            styleStrings.push(options.fontWeight.toString());\n        }\n    }\n    styleStrings.push(`${options.fontSize}px`);\n    styleStrings.push(`\"${options.fontFamily}\"`);\n    return styleStrings.join(\" \");\n};\nexports.getFontString = getFontString;\nconst parseColorString = (value) => {\n    const { r, g, b, a } = (0, exports.parseColor)(value);\n    return `rgba(${r}, ${g}, ${b}, ${a})`;\n};\nexports.parseColorString = parseColorString;\nconst parseColor = (value) => {\n    if (typeof value === \"string\") {\n        value = value.replace(/^0x/i, \"\");\n        value = value.replace(/^#/, \"\");\n        const r = (0, exports.parseHexTo255)(value.substr(0, 2), 0);\n        const g = (0, exports.parseHexTo255)(value.substr(2, 2), 0);\n        const b = (0, exports.parseHexTo255)(value.substr(4, 2), 0);\n        const a = (0, exports.parseHexTo255)(value.substr(6, 2), 255) / 255;\n        return { r, g, b, a };\n    }\n    else {\n        if (value <= 0xFFFFFF) {\n            const r = (value >> 16) & 0xFF;\n            const g = (value >> 8) & 0xFF;\n            const b = (value >> 0) & 0xFF;\n            const a = 1;\n            return { r, g, b, a };\n        }\n        else {\n            const r = (value >> 24) & 0xFF;\n            const g = (value >> 16) & 0xFF;\n            const b = (value >> 8) & 0xFF;\n            const a = ((value >> 0) & 0xFF) / 255;\n            return { r, g, b, a };\n        }\n    }\n};\nexports.parseColor = parseColor;\nconst parseHexTo255 = (value, defaultValue) => {\n    try {\n        if (value) {\n            const decimal = parseInt(`0x${value}`, 16);\n            if (!isNaN(decimal)) {\n                return Math.max(0, Math.min(decimal, 255));\n            }\n        }\n    }\n    catch (err) {\n        // ignore any error\n    }\n    return defaultValue;\n};\nexports.parseHexTo255 = parseHexTo255;\nconst hrtime = (previousHrTime) => {\n    if (process && process.hrtime) {\n        return process.hrtime(previousHrTime);\n    }\n    else {\n        const performance = window.performance;\n        const baseNow = Math.floor((Date.now() - performance.now()) * 1e-3);\n        const clocktime = performance.now() * 1e-3;\n        let seconds = Math.floor(clocktime) + baseNow;\n        let nanoseconds = Math.floor((clocktime % 1) * 1e9);\n        if (previousHrTime) {\n            seconds = seconds - previousHrTime[0];\n            nanoseconds = nanoseconds - previousHrTime[1];\n            if (nanoseconds < 0) {\n                seconds--;\n                nanoseconds += 1e9;\n            }\n        }\n        return [seconds, nanoseconds];\n    }\n};\nexports.hrtime = hrtime;\n","const inflate = require('tiny-inflate');\n\n// Shift size for getting the index-1 table offset.\nconst SHIFT_1 = 6 + 5;\n\n// Shift size for getting the index-2 table offset.\nconst SHIFT_2 = 5;\n\n// Difference between the two shift sizes,\n// for getting an index-1 offset from an index-2 offset. 6=11-5\nconst SHIFT_1_2 = SHIFT_1 - SHIFT_2;\n\n// Number of index-1 entries for the BMP. 32=0x20\n// This part of the index-1 table is omitted from the serialized form.\nconst OMITTED_BMP_INDEX_1_LENGTH = 0x10000 >> SHIFT_1;\n\n// Number of entries in an index-2 block. 64=0x40\nconst INDEX_2_BLOCK_LENGTH = 1 << SHIFT_1_2;\n\n// Mask for getting the lower bits for the in-index-2-block offset. */\nconst INDEX_2_MASK = INDEX_2_BLOCK_LENGTH - 1;\n\n// Shift size for shifting left the index array values.\n// Increases possible data size with 16-bit index values at the cost\n// of compactability.\n// This requires data blocks to be aligned by DATA_GRANULARITY.\nconst INDEX_SHIFT = 2;\n\n// Number of entries in a data block. 32=0x20\nconst DATA_BLOCK_LENGTH = 1 << SHIFT_2;\n\n// Mask for getting the lower bits for the in-data-block offset.\nconst DATA_MASK = DATA_BLOCK_LENGTH - 1;\n\n// The part of the index-2 table for U+D800..U+DBFF stores values for\n// lead surrogate code _units_ not code _points_.\n// Values for lead surrogate code _points_ are indexed with this portion of the table.\n// Length=32=0x20=0x400>>SHIFT_2. (There are 1024=0x400 lead surrogates.)\nconst LSCP_INDEX_2_OFFSET = 0x10000 >> SHIFT_2;\nconst LSCP_INDEX_2_LENGTH = 0x400 >> SHIFT_2;\n\n// Count the lengths of both BMP pieces. 2080=0x820\nconst INDEX_2_BMP_LENGTH = LSCP_INDEX_2_OFFSET + LSCP_INDEX_2_LENGTH;\n\n// The 2-byte UTF-8 version of the index-2 table follows at offset 2080=0x820.\n// Length 32=0x20 for lead bytes C0..DF, regardless of SHIFT_2.\nconst UTF8_2B_INDEX_2_OFFSET = INDEX_2_BMP_LENGTH;\nconst UTF8_2B_INDEX_2_LENGTH = 0x800 >> 6;  // U+0800 is the first code point after 2-byte UTF-8\n\n// The index-1 table, only used for supplementary code points, at offset 2112=0x840.\n// Variable length, for code points up to highStart, where the last single-value range starts.\n// Maximum length 512=0x200=0x100000>>SHIFT_1.\n// (For 0x100000 supplementary code points U+10000..U+10ffff.)\n//\n// The part of the index-2 table for supplementary code points starts\n// after this index-1 table.\n//\n// Both the index-1 table and the following part of the index-2 table\n// are omitted completely if there is only BMP data.\nconst INDEX_1_OFFSET = UTF8_2B_INDEX_2_OFFSET + UTF8_2B_INDEX_2_LENGTH;\n\n// The alignment size of a data block. Also the granularity for compaction.\nconst DATA_GRANULARITY = 1 << INDEX_SHIFT;\n\nclass UnicodeTrie {\n  constructor(data) {\n    const isBuffer = (typeof data.readUInt32BE === 'function') && (typeof data.slice === 'function');\n\n    if (isBuffer || data instanceof Uint8Array) {\n      // read binary format\n      let uncompressedLength;\n      if (isBuffer) {\n        this.highStart = data.readUInt32BE(0);\n        this.errorValue = data.readUInt32BE(4);\n        uncompressedLength = data.readUInt32BE(8);\n        data = data.slice(12);\n      } else {\n        const view = new DataView(data.buffer);\n        this.highStart = view.getUint32(0);\n        this.errorValue = view.getUint32(4);\n        uncompressedLength = view.getUint32(8);\n        data = data.subarray(12);\n      }\n\n      // double inflate the actual trie data\n      data = inflate(data, new Uint8Array(uncompressedLength));\n      data = inflate(data, new Uint8Array(uncompressedLength));\n      this.data = new Uint32Array(data.buffer);\n\n    } else {\n      // pre-parsed data\n      ({ data: this.data, highStart: this.highStart, errorValue: this.errorValue } = data);\n    }\n  }\n\n  get(codePoint) {\n    let index;\n    if ((codePoint < 0) || (codePoint > 0x10ffff)) {\n      return this.errorValue;\n    }\n\n    if ((codePoint < 0xd800) || ((codePoint > 0xdbff) && (codePoint <= 0xffff))) {\n      // Ordinary BMP code point, excluding leading surrogates.\n      // BMP uses a single level lookup.  BMP index starts at offset 0 in the index.\n      // data is stored in the index array itself.\n      index = (this.data[codePoint >> SHIFT_2] << INDEX_SHIFT) + (codePoint & DATA_MASK);\n      return this.data[index];\n    }\n\n    if (codePoint <= 0xffff) {\n      // Lead Surrogate Code Point.  A Separate index section is stored for\n      // lead surrogate code units and code points.\n      //   The main index has the code unit data.\n      //   For this function, we need the code point data.\n      index = (this.data[LSCP_INDEX_2_OFFSET + ((codePoint - 0xd800) >> SHIFT_2)] << INDEX_SHIFT) + (codePoint & DATA_MASK);\n      return this.data[index];\n    }\n\n    if (codePoint < this.highStart) {\n      // Supplemental code point, use two-level lookup.\n      index = this.data[(INDEX_1_OFFSET - OMITTED_BMP_INDEX_1_LENGTH) + (codePoint >> SHIFT_1)];\n      index = this.data[index + ((codePoint >> SHIFT_2) & INDEX_2_MASK)];\n      index = (index << INDEX_SHIFT) + (codePoint & DATA_MASK);\n      return this.data[index];\n    }\n\n    return this.data[this.data.length - DATA_GRANULARITY];\n  }\n}\n\nmodule.exports = UnicodeTrie;","// Returns a wrapper function that returns a wrapped callback\n// The wrapper function should do some stuff, and return a\n// presumably different callback function.\n// This makes sure that own properties are retained, so that\n// decorations and such are not lost along the way.\nmodule.exports = wrappy\nfunction wrappy (fn, cb) {\n  if (fn && cb) return wrappy(fn)(cb)\n\n  if (typeof fn !== 'function')\n    throw new TypeError('need wrapper function')\n\n  Object.keys(fn).forEach(function (k) {\n    wrapper[k] = fn[k]\n  })\n\n  return wrapper\n\n  function wrapper() {\n    var args = new Array(arguments.length)\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i]\n    }\n    var ret = fn.apply(this, args)\n    var cb = args[args.length-1]\n    if (typeof ret === 'function' && ret !== cb) {\n      Object.keys(cb).forEach(function (k) {\n        ret[k] = cb[k]\n      })\n    }\n    return ret\n  }\n}\n","/* (ignored) */","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","const UltimateTextToImage = require('ultimate-text-to-image')\r\n\r\nwindow.addEventListener('DOMContentLoaded', () => {\r\n  // const transformScrapedData = (scrapedData) => {\r\n  //   const { REDDIT_SCRAPED_DATA } = scrapedData\r\n  //   console.log(REDDIT_SCRAPED_DATA)\r\n  //   const titleData = REDDIT_SCRAPED_DATA[0]?.data?.children[0]?.data\r\n  //   /* has all the comments. Replies field has all of its children.\r\n  //   Follows the same data structure */\r\n  //   const commentData = REDDIT_SCRAPED_DATA[1]?.data?.children\r\n\r\n  //   console.log(titleData, commentData)\r\n  // }\r\n\r\n  const generateImage = (text) => {\r\n    // Fetches value\r\n    const selectedResolution = $('#resolution').val()\r\n    const backgroundColor = $('#backgroundColor').val()\r\n    const txtColor = $('#textColor').val()\r\n\r\n    let resolution\r\n    switch (selectedResolution) {\r\n      case 'square':\r\n        resolution = { width: 1080, height: 1080 }\r\n        break\r\n      case 'portrait':\r\n        resolution = { width: 1080, height: 1350 }\r\n        break\r\n      case 'landscape':\r\n        resolution = { width: 1080, height: 608 }\r\n        break\r\n      default:\r\n        resolution = { width: 400, height: 200 }\r\n        break\r\n    }\r\n    // Create a canvas element\r\n\r\n    const generatedImg = new UltimateTextToImage('geend')\r\n\r\n    console.log(generateImage)\r\n  }\r\n\r\n  const setDOMInfo = (info) => {\r\n    const isRedditComments = info?.SUCCESS\r\n    if (isRedditComments) {\r\n      $('.non-reddit').hide()\r\n      $('.loader').hide()\r\n      $('.container').show()\r\n      const title = info?.REDDIT_SCRAPED_DATA[0].data.children[0].data.title\r\n      $('.pageTitle').html(title)\r\n    } else {\r\n      $('.loader').hide()\r\n      $('.non-reddit').show()\r\n      $('.container').hide()\r\n    }\r\n  }\r\n\r\n  chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {\r\n    if (request.action === 'updateSelectedComments') {\r\n      console.log(request.text)\r\n      generateImage(request.text)\r\n    }\r\n  })\r\n\r\n  // ...query for the active tab...\r\n  chrome.tabs.query(\r\n    {\r\n      active: true,\r\n      currentWindow: true\r\n    },\r\n    (tabs) => {\r\n      // ...and send a request for the DOM info...\r\n      chrome.tabs.sendMessage(\r\n        tabs[0].id,\r\n        { from: 'popup', subject: 'DOMInfo' },\r\n        // ...also specifying a callback to be called\r\n        //    from the receiving end (content script).\r\n        setDOMInfo\r\n      )\r\n    }\r\n  )\r\n})\r\n","console.log('DOM load')\r\n\r\nchrome.runtime.sendMessage({\r\n  from: 'content',\r\n  subject: 'showPageAction'\r\n})\r\n\r\nconst PAGE_DATA_URL = `https://${window.location.host}${window.location.pathname}.json`\r\n\r\nconst runDataAnalysis = (data) => {\r\n  // Listen for messages from the popup.\r\n  chrome.runtime.onMessage.addListener((msg, sender, response) => {\r\n    if (\r\n      window.location.href.includes('https://www.reddit.com/r/') &&\r\n      window.location.href.includes('/comments/')\r\n    ) {\r\n      // * Only for reddit comment pages\r\n      if (msg.from === 'popup' && msg.subject === 'DOMInfo') {\r\n        // * checks the request subject, popup is asking for dom-info here\r\n        var domInfo = {\r\n          SUCCESS: true,\r\n          REDDIT_SCRAPED_DATA: data,\r\n          CURRENT_PAGE_URL: window.location.href\r\n        }\r\n        response(domInfo)\r\n      }\r\n    } else {\r\n      // * In case its not reddit\r\n      var domInfo = {\r\n        SUCCESS: false\r\n      }\r\n    }\r\n  })\r\n}\r\n\r\nlet selectedComments = []\r\n\r\nwindow.addEventListener('click', (event) => {\r\n  console.log(event.target)\r\n  if (event.target.tagName.toLowerCase() === 'p') {\r\n    chrome.runtime.sendMessage({\r\n      action: 'updateSelectedComments',\r\n      text: event.target.innerHTML\r\n    })\r\n  }\r\n})\r\n\r\n// * Fetches the data from page and then calls a function to broadcast message\r\n$.ajax({\r\n  url: PAGE_DATA_URL,\r\n  success: runDataAnalysis\r\n})\r\n"],"names":[],"sourceRoot":""}